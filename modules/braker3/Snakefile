#!/usr/bin/env python3

from snakemake.logging import logger


def get_collect_input(wildcards):
    if wildcards.type == "genome":
        return query_genome
    if wildcards.type == "proteins":
        return proteins
    else:
        raise ValueError(f"wtf {wildcards.type}")


###########
# GLOBALS #
###########

# containers
bbmap = "docker://quay.io/biocontainers/bbmap:39.01--h92535d8_1"
braker3 = "docker://teambraker/braker3:v.1.0.4"

# set up directories
outdir = Path(config["outdir"] if "outdir" in config else ".")
logger.debug(f"outdir: {outdir}")
logdir = Path(outdir, "logs")
benchdir = Path(logdir, "benchmarks")

# catch input
query_genome = config["query_genome"]
logger.info(f"braker3: input genome {query_genome}")

# optional input
braker_dict = {"ref": Path(outdir, "genome.fa")}
params_dict = {"ref": f'--genome={Path(braker_dict["ref"]).resolve()}'}

try:
    proteins = config["proteins"]
    braker_dict["proteins"] = Path(outdir, "proteins.fa")
    params_dict[
        "proteins"
    ] = f'--prot_seq={Path(braker_dict["proteins"]).resolve()}'
except KeyError:
    logger.info("braker3: no protein input")
    params_dict["proteins"] = ""

try:
    rnaseq = config["rnaseq"]
    braker_dict["rnaseq"] = rnaseq
    params_dict["rnaseq"] = f'--bam={Path(braker_dict["rnaseq"]).resolve()}'
except KeyError:
    logger.info("braker3: no rnaseq input")
    params_dict["rnaseq"] = ""

try:
    species_name = config["species_name"]
    params_dict["species"] = f"--species={species_name}"
except KeyError:
    logger.info("braker3: using default species name")
    params_dict["species"] = ""

logger.debug(braker_dict)
logger.debug(params_dict)


#########
# RULES #
#########


rule target:
    input:
        expand(
            Path(outdir, "{outfile}"),
            outfile=[
                "braker.aa",
                "braker.codingseq",
                "braker.gff3",
                "hintsfile.gff",
            ],
        ),


rule collect_output:
    input:
        Path(outdir, "braker", "{outfile}"),
    output:
        Path(outdir, "{outfile}"),
    threads: 1
    shell:
        "mv {input} {output}"


# braker3
# n.b. you have to cd to wd, otherwise braker overwrites the input file
rule braker3:
    input:
        **braker_dict,
    output:
        expand(
            Path(outdir, "braker", "{outfile}"),
            outfile=[
                "braker.aa",
                "braker.codingseq",
                "braker.gff3",
                "hintsfile.gff",
            ],
        ),
    params:
        **params_dict,
        wd=Path(outdir),
    log:
        Path(logdir, "braker3.log").resolve(),
    benchmark:
        Path(benchdir, "braker3.txt").resolve()
    threads: lambda wildcards, attempt: 20 * attempt
    resources:
        time=lambda wildcards, attempt: 10080 * attempt,
        mem_mb=lambda wildcards, attempt: 24e3 * attempt,
    container:
        braker3
    shell:
        "cd {params.wd} || exit 1 && "
        "braker.pl "
        "{params.ref} "
        "--gff3 "
        "--threads {threads} "
        "{params.proteins} "
        "{params.rnaseq} "
        "{params.species} "
        "&> {log}"


# collect input
# n.b. whitespace in the header breaks braker
rule reformat:
    input:
        get_collect_input,
    output:
        temp(Path(outdir, "{type}.fa")),
    params:
        ignorejunk=lambda wildcards: "t"
        if wildcards.type == "proteins"
        else "f",
    log:
        Path(logdir, "reformat.{type}.log"),
    container:
        bbmap
    shell:
        "reformat.sh "
        "fixheaders=t "
        "trimreaddescription=t "
        "ignorejunk={params.ignorejunk} "
        "in={input} "
        "out={output} "
        "2>{log}"
